import os
import sys
import json
import time
import base64
import threading
import functools
import boto3
import logging
from datetime import datetime, timezone
from botocore.config import Config

# --- Globals & Originals ---
_original_boto3_client = boto3.client
_trace_context = threading.local()

# --- Config ---
LOG_LEVEL_MAP = {"DEBUG": 10, "INFO": 20, "WARNING": 30, "ERROR": 40, "CRITICAL": 50}

SERVICE_CONFIG = {
    "s3": {
        "env_var": "S3_ENDPOINT",
        "config": Config(s3={"addressing_style": "path"}, signature_version="s3v4"),
    },
    "dynamodb": {
        "env_var": "DYNAMODB_ENDPOINT",
        "config": Config(
            retries={"max_attempts": 10, "mode": "standard"}, connect_timeout=5, read_timeout=5
        ),
    },
    "lambda": {
        "env_var": "GATEWAY_INTERNAL_URL",
        "config": Config(
            retries={"max_attempts": 10, "mode": "standard"}, connect_timeout=5, read_timeout=5
        ),
    },
}

# --- Helpers ---


def _get_current_trace_id():
    """現在の Trace ID を取得 (動的キャプチャ > 環境変数)"""
    return getattr(_trace_context, "current_trace_id", None) or os.environ.get("_X_AMZN_TRACE_ID")


def _sync_to_environ(trace_id):
    """取得した Trace ID を os.environ にも同期 (boto3標準の動作を補助)"""
    if not trace_id:
        return
    os.environ["_X_AMZN_TRACE_ID"] = trace_id


def _log_json(message, level="INFO", **kwargs):
    """sitecustomize内部ログをJSONで出力する"""
    entry = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "level": level,
        "message": message,
        "logger": "sitecustomize",
        "trace_id": _get_current_trace_id(),
        "_sitecustomize": True,
    }
    entry.update(kwargs)
    print(json.dumps(entry, ensure_ascii=False), flush=True)


class JsonFormatter(logging.Formatter):
    def format(self, record):
        log_entry = {
            "level": record.levelname,
            "message": record.getMessage(),
            "timestamp": datetime.fromtimestamp(record.created, tz=timezone.utc).isoformat(),
            "logger": record.name,
            "trace_id": _get_current_trace_id(),
            "location": f"{record.filename}:{record.lineno}",
        }
        if record.exc_info:
            log_entry["exc_info"] = self.formatException(record.exc_info)
        return json.dumps(log_entry, ensure_ascii=False)


# --- Logging Logic Class ---


class LocalLogHandler:
    """ローカルでのログ出力を担当するクラス"""

    @staticmethod
    def _get_iso8601_ms(ts_ms):
        dt = datetime.fromtimestamp(ts_ms / 1000.0, tz=timezone.utc)
        return dt.isoformat(timespec="milliseconds")

    @staticmethod
    def _estimate_container_name(log_group):
        if not log_group.startswith("/lambda/"):
            return "unknown"
        func_name = log_group[len("/lambda/") :]
        if func_name.endswith("-test"):
            func_name = func_name[:-5]
        name = f"lambda-{func_name}"
        return name[1:] if name.startswith("/") else name

    @classmethod
    def handle_put_log_events(cls, client, **kwargs):
        try:
            log_group = kwargs.get("logGroupName", "unknown")
            log_stream = kwargs.get("logStreamName", "unknown")
            log_events = kwargs.get("logEvents", [])
            container_name = cls._estimate_container_name(log_group)

            current_threshold = LOG_LEVEL_MAP.get(os.environ.get("LOG_LEVEL", "INFO").upper(), 20)

            # VictoriaLogs URL を環境変数から取得
            vl_url = os.environ.get("VICTORIALOGS_URL")

            for event in log_events:
                msg = event.get("message", "")
                ts_ms = event.get("timestamp", int(time.time() * 1000))

                level = "INFO"
                clean_msg = msg
                for lvl in LOG_LEVEL_MAP.keys():
                    if msg.startswith(f"[{lvl}]"):
                        level = lvl
                        clean_msg = msg[len(f"[{lvl}]") :].lstrip()
                        break

                if LOG_LEVEL_MAP.get(level, 20) < current_threshold:
                    continue

                log_entry = {
                    "_time": cls._get_iso8601_ms(ts_ms),
                    "level": level,
                    "message": clean_msg,
                    "log_group": log_group,
                    "log_stream": log_stream,
                    "logger": "boto3.mock",
                    "container_name": container_name,
                    "trace_id": _get_current_trace_id(),
                }

                # 標準出力への出力（Docker json-file ドライバー用）
                print(json.dumps(log_entry, ensure_ascii=False), flush=True)

                # VictoriaLogs への直接送信（環境変数が設定されている場合）
                if vl_url:
                    cls._send_to_victorialogs(vl_url, log_entry, container_name)

            return {"nextSequenceToken": "mock-token"}
        except Exception as e:
            print(f"[sitecustomize] Error in LocalLogHandler: {e}", flush=True)
            raise e

    @classmethod
    def _send_to_victorialogs(cls, vl_url, log_entry, container_name):
        """VictoriaLogs へ HTTP POST で送信。失敗時は何もしない（stdout にフォールバック済み）。"""
        import urllib.request
        import urllib.parse
        import urllib.error

        try:
            params = urllib.parse.urlencode(
                {
                    "_stream_fields": "container_name",
                    "_msg_field": "message",
                    "_time_field": "_time",
                    "container_name": container_name,
                }
            )
            full_url = f"{vl_url}?{params}"

            data = json.dumps(log_entry, ensure_ascii=False).encode("utf-8")
            req = urllib.request.Request(
                full_url,
                data=data,
                headers={"Content-Type": "application/json"},
                method="POST",
            )

            with urllib.request.urlopen(req, timeout=0.5) as res:
                res.read()
        except Exception:
            # 送信失敗は握りつぶす（stdout には既に出力済み）
            pass


# --- Logic: Auto Trace ID Hydration (Monkey Patching awslambdaric) ---


def _patch_awslambdaric():
    """
    awslambdaric.bootstrap.handle_event_request をモンキーパッチして
    Trace ID をハイドレーションし、stdout/stderr を VictoriaLogs にも送信する。
    """
    try:
        import awslambdaric.bootstrap
    except ImportError:
        # ローカル実行環境や異なるランタイムの場合はスキップ
        print("[sitecustomize] awslambdaric not found, skipping patch.", flush=True)
        return

    original_handle_event_request = awslambdaric.bootstrap.handle_event_request

    class VictoriaLogsStdoutHook:
        """stdout をフックして、書き込み時に VictoriaLogs にも送信するラッパー"""

        def __init__(self, original_stream, container_name, vl_url):
            self._original = original_stream
            self._container_name = container_name
            self._vl_url = vl_url

        def write(self, buf):
            # 元の stdout に書き込み
            self._original.write(buf)

            # VictoriaLogs にも送信（空行やスペースのみはスキップ）
            if self._vl_url and buf.strip():
                for line in buf.rstrip().splitlines():
                    if line.strip():
                        self._send_to_victorialogs(line)

        def _send_to_victorialogs(self, message):
            import urllib.request
            import urllib.parse
            import urllib.error

            try:
                # JSON 形式かどうかを判定
                try:
                    log_entry = json.loads(message)
                except (json.JSONDecodeError, ValueError):
                    log_entry = {
                        "_time": datetime.now(timezone.utc).isoformat(timespec="milliseconds"),
                        "level": "INFO",
                        "message": message,
                        "container_name": self._container_name,
                    }

                # container_name を追加（既存の値を上書きしない）
                if "container_name" not in log_entry:
                    log_entry["container_name"] = self._container_name

                params = urllib.parse.urlencode(
                    {
                        "_stream_fields": "container_name",
                        "_msg_field": "message",
                        "_time_field": "_time",
                        "container_name": self._container_name,
                    }
                )
                full_url = f"{self._vl_url}?{params}"

                data = json.dumps(log_entry, ensure_ascii=False).encode("utf-8")
                req = urllib.request.Request(
                    full_url,
                    data=data,
                    headers={"Content-Type": "application/json"},
                    method="POST",
                )

                with urllib.request.urlopen(req, timeout=0.5) as res:
                    res.read()
            except Exception:
                # 送信失敗は握りつぶす（stdout には既に出力済み）
                pass

        def flush(self):
            self._original.flush()

        def __getattr__(self, name):
            return getattr(self._original, name)

    @functools.wraps(original_handle_event_request)
    def patched_handle_event_request(
        lambda_runtime_client,
        request_handler,
        invoke_id,
        event_body,
        content_type,
        client_context,
        *args,
        **kwargs,
    ):
        # Trace ID Hydration
        try:
            ctx = client_context
            trace_id = None
            if hasattr(ctx, "custom") and isinstance(ctx.custom, dict):
                trace_id = ctx.custom.get("_X_AMZN_TRACE_ID")
            elif isinstance(ctx, dict) and "custom" in ctx:
                trace_id = ctx["custom"].get("_X_AMZN_TRACE_ID")

            if trace_id:
                os.environ["_X_AMZN_TRACE_ID"] = trace_id
                _trace_context.current_trace_id = trace_id
                _log_json(f"Hydrated _X_AMZN_TRACE_ID: {trace_id}")

        except Exception as e:
            _log_json(f"Error hydrating trace id: {e}", level="ERROR")

        # stdout/stderr フックのセットアップ
        original_stdout = sys.stdout
        original_stderr = sys.stderr
        vl_url = os.environ.get("VICTORIALOGS_URL")
        container_name = os.environ.get("AWS_LAMBDA_FUNCTION_NAME", "lambda-unknown")

        if vl_url:
            sys.stdout = VictoriaLogsStdoutHook(original_stdout, container_name, vl_url)
            sys.stderr = VictoriaLogsStdoutHook(original_stderr, container_name, vl_url)

        try:
            return original_handle_event_request(
                lambda_runtime_client,
                request_handler,
                invoke_id,
                event_body,
                content_type,
                client_context,
                *args,
                **kwargs,
            )
        finally:
            # stdout/stderr を元に戻す
            sys.stdout = original_stdout
            sys.stderr = original_stderr

            # Mitigation for log loss in short-lived containers on Windows
            try:
                sys.stdout.flush()
                sys.stderr.flush()
            except Exception:
                pass
            time.sleep(0.1)

    awslambdaric.bootstrap.handle_event_request = patched_handle_event_request
    print(
        "[sitecustomize] awslambdaric.bootstrap.handle_event_request patched for Trace ID hydration and VictoriaLogs.",
        flush=True,
    )


# --- Logic: ClientContext Injection (For RIE) ---


def _inject_client_context_hook(params, **kwargs):
    """
    [重要] Lambda RIE 対策
    RIE は HTTP ヘッダーの X-Amzn-Trace-Id を無視するため、
    ClientContext の custom 領域に trace_id を埋め込んで渡す。
    イベント: provide-client-params.lambda.Invoke
    """
    trace_id = _get_current_trace_id()
    if not trace_id:
        return

    # 既存の ClientContext をデコード (あれば)
    ctx_data = {}
    if "ClientContext" in params:
        try:
            ctx_data = json.loads(base64.b64decode(params["ClientContext"]).decode("utf-8"))
        except Exception as e:
            print(
                f"[sitecustomize] Warning: Failed to decode existing ClientContext: {e}", flush=True
            )

    # custom 領域に trace_id を注入
    if "custom" not in ctx_data:
        ctx_data["custom"] = {}

    # 既にセットされていなければセットする
    if "trace_id" not in ctx_data["custom"]:
        ctx_data["custom"]["trace_id"] = trace_id

        # 再エンコードして params を書き換え
        json_str = json.dumps(ctx_data)
        b64_str = base64.b64encode(json_str.encode("utf-8")).decode("utf-8")
        params["ClientContext"] = b64_str

        print(
            f"[sitecustomize] Injected Trace ID into ClientContext for RIE: {trace_id}", flush=True
        )


# --- Separated Patch Logic ---


def _create_mock_logs_client(args, kwargs):
    """CloudWatch Logs 用のローカルモッククライアントを作成"""
    print(
        "[sitecustomize] Creating original boto3 client for logs (local mock mode)...", flush=True
    )
    client = _original_boto3_client("logs", *args, **kwargs)
    _original_make_api_call = client._make_api_call

    def _patched_make_api_call(operation_name, api_params):
        if operation_name == "PutLogEvents":
            return LocalLogHandler.handle_put_log_events(client, **api_params)
        if operation_name in (
            "CreateLogGroup",
            "CreateLogStream",
            "DeleteLogGroup",
            "DeleteLogStream",
        ):
            return {}
        if operation_name == "DescribeLogGroups":
            return {"logGroups": []}
        if operation_name == "DescribeLogStreams":
            return {"logStreams": []}
        return _original_make_api_call(operation_name, api_params)

    client._make_api_call = _patched_make_api_call
    return client


def _configure_service_endpoint(service_name, kwargs):
    """環境変数に基づいてエンドポイント設定を注入"""
    service_cfg = SERVICE_CONFIG.get(service_name)
    if not service_cfg:
        return

    endpoint = os.environ.get(service_cfg["env_var"])
    if endpoint:
        kwargs["endpoint_url"] = endpoint
        kwargs["verify"] = False
        if service_cfg["config"]:
            existing = kwargs.get("config")
            kwargs["config"] = (
                existing.merge(service_cfg["config"]) if existing else service_cfg["config"]
            )
        print(f"[sitecustomize] Redirecting {service_name} to {endpoint}", flush=True)


def _register_lambda_hooks(client):
    """Lambda Invoke 用の ClientContext 注入フックを登録"""
    client.meta.events.register("provide-client-params.lambda.Invoke", _inject_client_context_hook)
    print("[sitecustomize] Registered ClientContext hook for lambda.Invoke", flush=True)


def _patched_boto3_client(service_name, *args, **kwargs):
    try:
        # 1. Logs (Mock) の場合
        if service_name == "logs":
            return _create_mock_logs_client(args, kwargs)

        # 2. その他のサービス (Endpoint Redirection)
        _configure_service_endpoint(service_name, kwargs)

        # クライアント作成
        client = _original_boto3_client(service_name, *args, **kwargs)

        # 3. Lambda の場合 (Hook Registration)
        if service_name == "lambda":
            _register_lambda_hooks(client)

        return client

    except Exception as e:
        print(f"[sitecustomize] Error in _patched_boto3_client for {service_name}: {e}", flush=True)
        import traceback

        traceback.print_exc()
        raise e


# --- Logic: Logging Module Patch (Standard Python Logging) ---


def _patch_logging():
    root = logging.getLogger()
    for h in root.handlers:
        root.removeHandler(h)

    handler = logging.StreamHandler(sys.stdout)
    handler.setFormatter(JsonFormatter())
    root.addHandler(handler)

    # 既存の環境変数レベル設定を尊重
    root.setLevel(os.environ.get("LOG_LEVEL", "INFO").upper())
    _log_json("Patched standard logging to output JSON.")


# --- Apply Patches ---

boto3.client = _patched_boto3_client

# Patch awslambdaric
_patch_awslambdaric()

# Patch logging
_patch_logging()

_log_json(f"Loaded. boto3 ID: {id(boto3)}")
_log_json("All patches applied. RIE Trace ID bridge enabled.")
